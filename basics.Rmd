---
title: "UMAP_basics"
output: html_document
date: "2023-01-18"
---

Put here the location of your data, and where you want the created files to be stored, I recommend to make a new folder for this
```{r}
data_source <- "L:/DMS/AV_501_Pooja_Mandaviya/AV501v3_Pooja_Mandaviya_20220825.sav"     
output_location <- "P:/FSE_MACSBIO/Smit, Femke/clustering project/test"
#e.g. "C:/Users/Fariba/Documents"
```


```{r results="hide"}
set.seed(123)
library(haven)
library(readr)
library(dplyr, warn.conflicts = FALSE)
library(tidyr, warn.conflicts = FALSE)
library(purrr)
library(ggplot2)
library(ggdensity)
library(patchwork)
library(Matrix, warn.conflicts = FALSE)
library(uwot)
library(survival)
library(igraph)
library(broom)
library(ggh4x)
library(mvtnorm)
library(stringr)
```


Reading the data:
```{r results = "hide"}
setwd(output_location)
data <- read_sav(data_source)
nrow(data)
# Subsetting only the columns that you need! Adapt this to the column names of your variables
dat <- data %>% select(
  RandomID,
  Age,
  SEX, 
  smoking_packyears,    ## Smoking should be a binary variable with 1 for yes (current smoker) and 0 for no (not current smoker, you can adapt this later if that is not how it is coded in your datafile)
  smoking_3cat,
  smoking_4cat,
  bmi,
  N_WHR,
  OSBP,
  ODBP,
  LDL,
  HDL,
  Triglyc, 
  CRP_2016F,   #creatinine
  Glucose_t0_FP,
  ALAT_serum,
  med_LP,
  med_HT,
  GFR_CKDEPI_cr)


# Coding for Females and Males in the right way
dat$SEX1 <- ifelse(dat$SEX == 2, "Female", "Male")  #In this script, male was coded as 1, female as 2
dat$SEX <- NULL
```

Looking into the smoking variables
```{r}
# Smoking should be a binary variable with 1 for yes (current smoker) and 0 for no (not current smoker)
# Here I create a new category, smoking_2cat, where this gets recoded (0 and 1 (never and former smoker) both get turned into 0, 2 (current smoker) gets turned into 1)
summary(dat[,c("smoking_packyears", "smoking_3cat", "smoking_4cat")])
dat$smoking_2cat <- replace(dat$smoking_3cat, dat$smoking_3cat==1, 0)
dat$smoking_2cat <- replace(dat$smoking_2cat, dat$smoking_2cat==2, 1)

dat$smoking_3cat <- NULL
dat$smoking_4cat <- NULL
dat$smoking_packyears <- NULL
```

```{r}
# Remove outliers and complete cases
remove_outliers <- function(x){
  m <- mean(x, na.rm = TRUE)
  s <- sd(x, na.rm = TRUE)
  upperbound <- m + (5*s)
  lowerbound <- m - (5*s)
  ifelse((x > lowerbound) & (x < upperbound), x, NaN)
}

dat <- dat %>% mutate(across(-c(RandomID, SEX1, Age), remove_outliers)) %>% drop_na #drop_na to take only complete cases

#renaming variables
#replace the variables after the = with your variable names
dat <- rename(dat, eid = RandomID)
dat <- rename(dat, age = Age)
dat <- rename(dat, sex = SEX1)
dat <- rename(dat, whr = N_WHR)
dat <- rename(dat, hdl = HDL)
dat <- rename(dat, tg = Triglyc)
dat <- rename(dat, crp = CRP_2016F)
dat <- rename(dat, fg = Glucose_t0_FP)
dat <- rename(dat, alt = ALAT_serum)
dat <- rename(dat, ldl = LDL)
dat <- rename(dat, sbp = OSBP)
dat <- rename(dat, dbp = ODBP)
dat <- rename(dat, smoking = smoking_2cat)
dat <- rename(dat, scr = GFR_CKDEPI_cr)

#reorder columns
dat <- dat[,c("eid","age","sex","bmi","whr","sbp","dbp","alt","scr","crp","hdl","tg","ldl","fg","smoking")]
#dat_smallsmoking <- dat
#dat_smallsmoking[,"smoking"] != 0 
recoded_dat <- dat
```
```{r}
#write.table(strat_dat, file = "P:/FSE_MACSBIO/Smit, Femke/clustering project/data/strat_dat.tsv", sep = "\t", row.names = FALSE)
```



# Stratification by sex and transformation
Residualization by BMI, age and smoking. Then scaling residuals to mean 0 and SD 1.
```{r}
strat_dat <- recoded_dat %>%
  split(f = .$sex) %>%
  map(
    ~{
      .x %>%
        names %>%
        setdiff(c("eid", "sex", "age", "smoking", "bmi")) %>%
        map_dfc(
          function(feature){
            paste(feature, "~ age + smoking + bmi") %>%
              lm(data = .x) %>%
              resid %>%
              scale %>%
              data.frame %>%
              setNames(feature)
          }
        ) %>%
        mutate(eid = .x$eid, .before = 1)
    }
  )
map(strat_dat, head)
strat_dat %>%
  map(nrow)
```



# Non-linear projection using UMAP
Separately for each sex:
```{r}
umap_res <- strat_dat %>%
  map(
    ~{
      dat <- select(.x, -eid)
      n_total <- nrow(dat)
#      nn <- round(10 + 15 * (log10(n_total) - 3)) #was -4, made into -3 as it gave an error, said it had to be >=2
      nn <- 10    #as instructed by Daniel
      umap(
        # Data and number of dimensions to return
        dat, n_components = 2, 
        # Parameters to build the nearest-neighbor graph
        n_neighbors = nn, nn_method = "annoy", n_trees = 100, 
        n_sgd_threads = "auto", 
        # Parameters for the embedding
        init = "pca", n_epochs = 500, approx_pow = TRUE,
        binary_edge_weights = TRUE, dens_scale = 1, 
        # Additional elements to return
        ret_extra = c("model", "nn", "fgraph"),
        verbose = FALSE,
        ret_model = TRUE
      )
    }
  )
```

# Clustering
```{r}
umap_graphs <- umap_res %>%
  map(~igraph::graph_from_adjacency_matrix(.x$fgraph, mode = "undirected")) %>%
  map2(strat_dat, ~{ igraph::V(.x)$name <- .y$eid; .x })

umap_graphs %>%
  map(~.x)
```

# Finding communities within the graphs
Clustering using the Leiden algorithm, with initial seeds using the leading eigenvector:
```{r}
graph_clusters <- umap_graphs %>%
  map(~igraph::cluster_leading_eigen(.x)) %>%
  map2(umap_graphs, 
       ~igraph::cluster_leiden(.y, objective_function = "modularity", initial_membership = .x$membership, n_iterations = 500))
```

Extracting memberships:  
```{r}
memb_dat <- graph_clusters %>%  #said graph_lev first instead of graph_clusters
  map(igraph::membership) %>%
  map(~data.frame(eid = as.numeric(names(.x)), cluster = as.numeric(.x)))
map(memb_dat, head)
```

Extracting the corresponding subgraphs of each cluster:
```{r}
cluster_subgraphs <- memb_dat %>%
  map2(
    umap_graphs,
    ~{
      .x %>%
        split(f = .$cluster) %>%
        map(
          function(clus){
            igraph::induced_subgraph(.y, as.character(clus$eid))
          }
        )
    }
  )
```

To locate the 'centers' of these clusters, we can use the eigenvector centrality, which returns a value between 0 and 1. The higher the value, the higher the importance of an individual in the network:
```{r}
ev_dat <- cluster_subgraphs %>%
  map(
    ~{
      map_df(
        .x, 
        function(clus){ 
          evcent <- igraph::eigen_centrality(clus, directed = FALSE)$vector
          data.frame(
            eid = as.numeric(names(evcent)),
            value = as.numeric(evcent)
          )
        },
        .id = "cluster"
      ) %>%
        mutate(cluster = as.numeric(cluster))
    }
  )
map(ev_dat, head)
```

# Obtaining subdistributions from each cluster
For this we need to estimate mean/covariance matrix using eigen centrality as weights:

```{r}
cluster_pars <- ev_dat %>%
    map2(strat_dat, inner_join) %>%
    map(
        ~{
            .x %>%
                split(f = .$cluster) %>%
                map(
                    function(clusdat){
                        cov.wt(select(clusdat, whr, sbp, dbp, alt, scr, crp, hdl, tg, ldl, fg), wt = clusdat$value, cor = TRUE)
                    }
                )
        }
    )
```

# Adding 'central' subdistribution

This would correspond to individuals whose biomarker values are perfectly explained by BMI:
```{r}
center_subdis <- list(
    cov = diag(rep(1, ncol(strat_dat$Female) - 1)),
    center = rep(0, ncol(strat_dat$Female) - 1)
)
center_subdis

cluster_pars0 <- cluster_pars %>%
    map(~{.x$`0` <- center_subdis; .x})
map(cluster_pars0, names)
```

```{r}
gmm_res <- cluster_pars0 %>%
    map2(
        strat_dat,
        ~{
            d <- select(.y, -eid)
            mus <- map(.x, function(clus){ clus$center })
            covmats <- map(.x, function(clus){ clus$cov })
            pdfs <- map2(mus, covmats, function(mu, covmat){ mvtnorm::dmvnorm(d, mu, covmat) })
            k <- length(mus)
            ws <- rep(1 / k, k)
            L <- map2(pdfs, ws, function(pd, w){ pd * w })
            Lmat <- do.call(cbind, L)
            probs <- Lmat / rowSums(Lmat)
            Lclus <- colSums(probs)
            loglik <- sum(log(rowSums(Lmat)))
            Delta <- 1
            iter <- 1
            itermax <- 100
            while(Delta > 1e-10 && iter <= itermax){
                ws <- Lclus / sum(Lclus)
                L <- map2(pdfs, ws, function(pd, w){ pd * w })
                Lmat <- do.call(cbind, L)
                probs <- Lmat / rowSums(Lmat)
                Lclus <- colSums(probs)
                loglik_current <- sum(log(rowSums(Lmat)))
                Delta <- loglik_current - loglik
                loglik <- loglik_current
                iter <- iter + 1
            }
            print(paste("Convergence reached in", iter, "iterations"))
            list(probs = probs, weights = ws)
        }
    )

```



```{r}
cluster_params <- cluster_pars0 %>%
    map2(gmm_res, 
         ~map2(
             .x, .y$weights,
             function(clus, clusw){
                 clus$weight <- clusw
                 clus[c("center", "cov", "weight")]
                 }
             )
         )

varnames <- names(cluster_params$Female[[1]]$center)

map(cluster_params, map, names) %>%
    unlist %>%
    unique
```




# Calculating probabilities to belong to each subdistribution for every individual



Function to get probabilities to be assigned to each subdistribution:

```{r}
# Function that returns probabilities for a given mixture of Gaussian distributions
# X = Data
# center = List of centers of each Gaussian distribution
# covmats = List of covariance matrices for each Gaussian distribution
# weights = List o weights for each Gaussian distribution
getclusprob <- function(X, centers, covmats, weights){
    # Calculating probability density functions
    pdfs <- map2(centers, covmats, function(mu, covmat){ mvtnorm::dmvnorm(X, mu, covmat) })
    # Calculating likelihoods
    L <- map2(pdfs, weights, function(pd, w){ pd * w })
    # Joining in a matrix
    Lmat <- do.call(cbind, L)
    # Scaling by row to obtain probabilities
    probs <- Lmat / rowSums(Lmat)
    probs
}
```




```{r}

library(Hmisc)

getclusproball <- function(dataset, cluspars){
  d <- select(dataset, -eid)
  centers <- map(cluspars, pluck, "center")
  covmats <- map(cluspars, pluck, "cov")
  weights <- map(cluspars, pluck, "weight")
  getclusprob(d, centers, covmats, weights)
}



cluster_probs <- map2(strat_dat, cluster_params, getclusproball) 

```





