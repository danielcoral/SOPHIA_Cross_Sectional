---
title: An R Markdown document converted from "GuidelineValidation.ipynb"
output: html_document
---

# Heterogeneity in the relationship between BMI and risk biomarkers

---

***Authors:***

- Daniel E. Coral

- Femke Smit

- Elena Santos

- Ali Farzaneh

---

## Introduction

This is a guideline to be followed by analysts in SOPHIA who are participating in the cross-sectional clustering project in the general population in Working Group 1. The idea is to standardize every step of the analysis across cohorts.

Not everyone has to follow all the steps, as we require different things from every cohort. We have divided the participating cohorts into 4 groups:

|Cohort group|Cohorts|
|-:|-:|
|*Discovery*|UK Biobank|
|*Validation*|Maastricht|
||Rotterdam|
||GHS|
|*Mental health*|Girona|
||Maastricht|
|*Intervention*|SCALE|
||ABOS|

This guideline is designed to be applied in discovery and validation cohorts. We will then apply what we learn in these cohorts to the mental health and intervention cohorts.

---

As a background, generally the relationship between BMI and multiple diseases is assumed to follow a continuum -- the higher the BMI, the higher the risk. However, it has also been found that in certain groups of people this relationship is disproportionally stronger or weaker for any given BMI. Our objective is to test the hypothesis that clustering-based approaches can be used to better capture these subgroups. An overview of the steps of our pipeline to test this hypothesis is shown in Figure 1.

|![image.png](attachment:f8b0dea3-1987-4811-8e4a-0877b1297a75.png)|
|-|
|*Figure 1. Pipeline overview*|

---

## Software

All steps are intended to be followed in the R environment. To facilitate the analyses we have put together a list of functions that can be used to run every step of this guideline. They are located in the accompanying file `cross_sectional_FX.R`, which you can load like this:

```{r}
source("cross_sectional_FX.R")
```

These functions have dependencies on the following packages:

```{r}
suppressMessages({
    library(tibble)
    library(readr)
    library(dplyr)
    library(tidyr)
    library(purrr)
    library(uwot)
    library(igraph)
    library(mvtnorm)
    library(survival)
})
```

The environment where discovery analysis in UK Biobank was executed is then the following:

```{r}
sessionInfo()
```

---

## Initial input

We have selected 10 traits, based on biological systems that are commonly affected by obesity:

- Blood pressure: SBP and DBP.
- Lipids: HDL, LDL, TG.
- Fat distribution: WHR.
- Glycemia: Fasting glucose.
- Liver metabolism: ALT.
- Kidney function: Creatinine.
- Inflammation: CRP.

The covariates that will be needed are:

- Sex.
- Age.
- Current smoking status, coded as 1 if current smoker, 0 otherwise.

The initial input table should look like the following:

```{r}
recoded_dat <- read_tsv("../data/recoded_dat.tsv", show_col_types = FALSE)
head(recoded_dat)
```

The units of the contiuous variables we expect to run the analysis:

- Age in years.
- Sex as a string of either "Female" or "Male".
- BMI in kg/m2.
- WHR is unitless, calculated by dividing waist and hip circumferences measured in cm.
- SBP and DBP in mmHg.
- ALT in U/L.
- sCr in umol/L.
- CRP in mg/L.
- HDL in mmol/L.
- TG in mmol/L.
- LDL in mmol/L.
- FG in mmol/L.
- Smoking as a dummy variable: 1 if currently smoking, 0 otherwise.

<font color=red size=3.5>***Note:***</font> 

For the functions included in the `cross_sectional_FX.R` to work, the input table should be ***exactly*** as shown above.

---

## Missing data

Since our clustering method ignores individuals with missing values for any biomarker, the input data should only contain individuals who have all biomarker values. From the previous analyses, we know that:

- Only including complete cases without losing too much data is possible in UK Biobank, Maastricht, GHS and ABOS.
- In Rotterdam the initial input table contains some values have been imputed using a random forest algorithm.
- In Girona only a small subset of individuals have CRP values.
- In SCALE there are values for waist but not for hip circumference, so it is not possible to calculate WHR.

Based on these observations we have made the following decisions on how to deal with missing values:

|How to handle missing values|Cohorts|
|-:|-:|
|Only include complete cases.|UK Biobank|
||Maastricht|
||GHS|
||ABOS|
|||
|Use data that has been imputed.|Rotterdam|
|||
|Retain all individuals.|Girona|
||SCALE|

***For the cohorts in the last group***, to be able to apply our method, we will assume that BMI explains the variability in the biomarkers that are missing. This assumption is based on what we have observed in the other cohorts. In practice, this means that the clustering method will focus on the biomarkers that are available to group individuals into clusters. The input table should still have the same columns so that the functions in `cross_sectional_FX.R` work properly.

---

## Remove possible errors in measurement

In discovery and validation cohorts we will exclude biomarker measurements that are 5 SD away from the mean, under the assumption that these are most likely measurement errors. This can be done using the `remove_outliers` function that we have provided, which replaces outliers with `NA` values. Then we again make sure to have only complete cases:

```{r}
recoded_dat <- mutate(recoded_dat, 
                      across(c(bmi, whr, sbp, dbp, alt, scr, crp, hdl, tg, ldl, fg), 
                             ~remove_outliers(.x, sdunits = 5)))
recoded_dat <- recoded_dat[complete.cases(recoded_dat),]
```

---

## Stratify by sex

All the pipeline is applied separately in each sex group. The functions we have designed work on a list containing two dataframes for each sex group, which we can obtain like this:

```{r}
strat_dat <- split(recoded_dat, ~sex)
```

To see the first lines of the two elements in the list:

```{r}
lapply(strat_dat, head)
```

---

## Summary of initial input

We need a table summarising the initial input, which can be generated like this:

```{r}
gendesc_tab <- get_general_descriptives(strat_dat)
gendesc_tab
```

For smoking:

- `Summary1` contains the categories.
- `Summary2` contains the proportion of each category.

For the rest (continuous) variables:

- `Summary1` contains the mean and standard deviation.
- `Summary2` contains the median and interquartile range.

---

## Estimates of BMI-biomarker associations

The first step of the pipeline is to generate sex-specific linear models of BMI for each variable, adjusting for age, and smoking. To do that we have the following function:

```{r}
mods <- get_bmimods(strat_dat)
```

The result is a table with a column that contains the models specific for each sex and biomarker:

```{r}
print(mods)
```

As an example, we can print the summary of the female model for CRP:

```{r}
summary(mods$mod[mods$sex == "Female" & mods$Biomarker == "crp"][[1]])
```

We then use this table to generate a table containing the estimates of the effect of BMI on every biomarker:

```{r}
bmicoefs_tab <- get_bmicoefs(mods)
bmicoefs_tab
```

---

## Generate table with residual values

The next step in the pipeline is to calculate for each individual how much they deviate from the expected given the BMI. To do that we have the following function:

```{r}
residtab <- get_residtabs(strat_dat, mods)
```

```{r}
lapply(residtab, head)
```

---

## Obtaining clusters and probabilities of allocation

We use this residuals to run UMAP, which we use not only to obtain a projection of residual data in 2 dimensions, but also to run a probabilistic network clustering algorithm. We have wrapped all the clustering steps in a single function that we apply to the `residtab` object:

```{r}
cluster_results <- get_cluster_results(residtab)
```

The result is a list containing the UMAP model, the parameters of the clusters found, the modularity score, which is a measure of the quality of the network partition, and the allocation probabilities of individuals to all clusters:

```{r}
lapply(cluster_results, names)
```

---

## Table summarising clusters

To understand what characterizes the clusters found, we will need a table with descriptives of the distribution of residuals per cluster, which can be generated like this:

```{r}
clustersummary <- get_clustersummary(cluster_results)
```

```{r}
head(clustersummary)
```

We also need the distribution of the biomarkers in the clusters in their natural scale. To calculate this for a specific cluster, we use all individuals, and weigh each individual by their corresponding cluster allocation probability. The function for this is the following:

```{r}
cluster_descriptives <- get_cluster_descriptives(cluster_results, strat_dat)
```

```{r}
head(cluster_descriptives)
```

---

## Relationship between BMI and biomarkers in each cluster

Given that the relationship between BMI and biomarkers is expected to be different in these clusters compared to the overall relationship found above, we will quantify how much it changed by comparing models weighted by probabilities of each cluster. The function is the following:

```{r}
clusbmicoefs <- get_bmicoefs_clusters(cluster_results, strat_dat)
```

```{r}
head(clusbmicoefs)
```

---

## Disease prevalence

The next step is to check whether the prevalence of certain diseases differ in the clusters found, which would give us an initial idea of the clinical relevance of these subgroups. To do that we expect a table where each column represents a disease, coded as 1 or 0 depending on the presence or absence of the disease for each individual ***included in the clustering analysis***:

```{r}
disease_dat <- inner_join(read_tsv("../data/selected_dx.tsv", show_col_types = FALSE),
                          read_tsv("../data/anycadat.tsv", show_col_types = FALSE),
                          by = "eid") %>%
    ## Only people who were included in the clustering analysis
    filter(eid %in% recoded_dat$eid)
head(disease_dat)
```

Diseases in this table are commonly associated with obesity; the list includes:

```{r}
colnames(disease_dat)[-1]
```

***Note:*** We don't expect to have all diagnoses available in all validation cohorts, but the more the better!

The first thing we need is a table summarising the sex-specific prevalence of each disease:

```{r}
overall_diseasesum <- get_diseasesummary(disease_dat, strat_dat)
```

```{r}
head(overall_diseasesum)
```

Then, we will need a table summarising the prevalence within each cluster, which is again calculated using the cluster probabilites as weights:

```{r}
cluster_diseasesum <- get_diseasesummary_clusters(disease_dat, cluster_results)
```

```{r}
head(cluster_diseasesum)
```

Some of the prevalences may be affected by subtle residual differences in the covariates we adjusted for before clustering (i.e., age, smoking and most importantly, BMI), and also certain medications. To control for that:

- We will treat 'cluster 0', the cluster characterized by all biomarkers being aligned with BMI, as the reference cluster.
- For each disease, we will calculate the increase in disease OR that corresponds to a unit increase in cluster allocation probability of every cluster relative to 'cluster 0', while all other covariates remain equal. 

To do that we need an additional table containing medication data, which should look like this:

```{r}
meds_dat <- read_tsv("../data/selected_meds.tsv", show_col_types = FALSE)
head(meds_dat)
```

We defined people receiving medications using the following ATC codes:

|Medication group|ATC codes|
|:-:|:-:|
|Insulin|A10A|
|Other antidiabetic|A10B|
|Antihypertensives|C01|
||C02|
||C03|
||C07|
||C08|
||C09|
|Lipid lowering|C10|

The function to run an adjusted analysis is the following:

```{r}
cluster_adjdiseasesum <- get_adjdiseasesummary_clusters(cluster_results, disease_dat, meds_dat, strat_dat)
```

```{r}
head(cluster_adjdiseasesum)
```

These latter estimates represent the change in the logarithm of the OR for a disease per each unit change in the logarithm of cluster probability. The rationale for using this transformation is to back-transform the estimates so that they represent the change in the OR for a certain percent increase/decrease in probability.

As a complementary analysis, we would calculate these OR by allocating individuals to a certain cluster based on different thresholds. The function for that is the following:

```{r}
cluster_adjdiseasesum_thresh <- get_adjdiseasesummary_clustersthresh(cluster_results, disease_dat, meds_dat, strat_dat, thresh = c(.6, .7, .8))
```

```{r}
head(cluster_adjdiseasesum_thresh)
```

These estimates represent the change in the logarithm of the OR for change in cluster membership relative to cluster 0 - the concordant cluster.

---

## MACE incidence - UK Biobank, Rotterdam (GHS?)

Next, we will calculate the risk of future disease given the probability of cluster allocation. The table we expect to able to run this part looks like the following:

```{r}
survmacedat <- read_tsv("../data/survmacedat.tsv", show_col_types = FALSE)
head(survmacedat)
```

The first thing we need, as done before, is a sex-specific summary of the data available:

```{r}
macesum <- get_incidencesummary(survmacedat, strat_dat)
```

```{r}
macesum
```

And again, we would run similar cluster-specific analyses as done for prevalence:

- Crude incidence per cluster:

```{r}
cluster_macesum <- get_incidencesummary_clusters(survmacedat, cluster_results)
```

```{r}
cluster_macesum
```

- Unadjusted and adjusted survival models with cluster probabilities as predictors:

```{r}
cluster_adjmacesum <- get_adjincidencesummary_clusters(cluster_results, survmacedat, meds_dat, strat_dat)
```

```{r}
head(cluster_adjmacesum)
```

- Unadjusted and adjusted survival models with hard cluster allocation at different thresholds as predictor:

```{r}
cluster_adjmacesum_thresh <- get_adjincidencesummary_clustersthresh(cluster_results, survmacedat, meds_dat, strat_dat, thresh = c(.6, .7, .8))
```

```{r}
head(cluster_adjmacesum_thresh)
```

We want to know whether a simple survival model using all biomarkers is able to capture the risk we observe in the clusters. To do that we first construct this simple survival model:

```{r}
globalmod_mace <- global_survivalmodel(strat_dat, survmacedat)
```

The result is a sex specific survival model:

```{r}
lapply(globalmod_mace, class)
```

Each model includes all variables, e.g.:

```{r}
summary(globalmod_mace$Female)$coefficients
```

We then extract the probability assigned by these models to each individual to be free of MACE events after 5 years of follow-up, and then we assess both the overall and the cluster-specific predictive performance. For the first we have the following function:

```{r}
global_survmetrics_mace <- global_survmetrics(globalmod_mace, strat_dat, survmacedat)
```

This function returns for each sex a list containing 2 elements:
- A table containing multiple thresholds of survival probabilities, and their corresponding number of true/false positives and true/false negatives, which we can use to calculate ROC curves.
- A calculation of the variance parameters around the ROC AUC estimate, which we will use to formally compare 2 ROC AUCs using Delong's method.

For example, these is how this object looks like for females:

```{r}
str(global_survmetrics_mace$Female)
```

We will also calculate these same estimates for each cluster. We will do this by weighting individuals by their cluster probabilities:

```{r}
cluster_survmetrics_mace <- cluster_survmetrics(globalmod_mace, strat_dat, survmacedat, cluster_results)
```

The result is similar as before, for each cluster identified:

```{r}
str(cluster_survmetrics_mace$Female$cluster_1)
```

---

## Diabetes risk - UK Biobank, Rotterdam (GHS?)

Given the strong link between BMI and T2D, we will also test whether one of the clusters identified is associated with higher or lower risk of developing diabetes over time. The data we need looks just like the one we used above for MACE:

```{r}
survdmdat <- read_tsv("../data/survdmdat.tsv", show_col_types = FALSE)
head(survdmdat)
```

We will then apply the same functions as we did for MACE:

- Sex-specific summary of the data available:

```{r}
timetodmsum <- get_incidencesummary(survdmdat, strat_dat)
```

```{r}
timetodmsum
```

- Crude incidence per cluster:

```{r}
cluster_timetodmsum <- get_incidencesummary_clusters(survdmdat, cluster_results)
```

```{r}
head(cluster_timetodmsum)
```

- Unadjusted and adjusted survival models with cluster probabilities as predictors (here ignoring medication):

```{r}
cluster_adjtimetodmsum <- get_adjincidencesummary_clusters(cluster_results, survdmdat, meds_dat[,"eid"], strat_dat)
```

```{r}
head(cluster_adjtimetodmsum)
```

- Unadjusted and adjusted survival models with hard cluster allocation at different thresholds as predictor:

```{r}
cluster_adjtimetodmsum_thresh <- get_adjincidencesummary_clustersthresh(cluster_results, survdmdat, meds_dat[,"eid"], strat_dat, thresh = c(.6, .7, .8))
```

```{r}
head(cluster_adjtimetodmsum_thresh)
```

- Overall survival model:

```{r}
globalmod_timetodm <- global_survivalmodel(strat_dat, survdmdat)
```

```{r}
lapply(globalmod_timetodm, class)
```

- Overall predictive performance at 5 years:

```{r}
global_survmetrics_timetodm <- global_survmetrics(globalmod_timetodm, strat_dat, survdmdat)
```

- Cluster-specific predictive performance at 5 years, weighted by probabilities:

```{r}
cluster_survmetrics_timetodm <- cluster_survmetrics(globalmod_timetodm, strat_dat, survdmdat, cluster_results)
```

---

## Gathering and saving results

We'll save all results in a single file:

```{r}
result_file <- list(
    General_descriptives = gendesc_tab,
    BMI_coefficients = bmicoefs_tab,
    Cluster_results = cluster_results,
    Cluster_summary = clustersummary,
    Cluster_descriptives = cluster_descriptives,
    Cluster_BMI_coefficients = clusbmicoefs,
    Disease_summary = overall_diseasesum,
    Cluster_Disease_summary = cluster_diseasesum,
    Cluster_Disease_summary_Adjusted = cluster_adjdiseasesum,
    Cluster_Disease_summary_Threshold = cluster_adjdiseasesum_thresh,
    MACE_summary = macesum,
    Cluster_MACE_summary = cluster_macesum,
    Cluster_MACE_summary_Adjusted = cluster_adjmacesum,
    Cluster_MACE_summary_Threshold = cluster_adjmacesum_thresh,
    Global_SurvMetrics_MACE = global_survmetrics_mace,
    Cluster_SurvMetrics_MACE = cluster_survmetrics_mace,
    TimetoDM_summary = timetodmsum,
    Cluster_TimetoDM_summary = cluster_timetodmsum,
    Cluster_TimetoDM_Adjusted = cluster_adjtimetodmsum,
    Cluster_TimetoDM_Threshold = cluster_adjtimetodmsum_thresh,
    Global_SurvMetrics_TimetoDM = global_survmetrics_timetodm,
    Cluster_SurvMetrics_TimetoDM = cluster_survmetrics_timetodm
)
```

```{r}
save(result_file, file = "result_file.RData")
```

---

## Uploading results

The results shown do not contain any individual level data. We require that you upload this 'result_file.RData' file to the Teams folder in SOPHIA, which would be located here:

> CrossWP > Analyst working groups > WG1 > UMAP_project > *cohort_name* > data

```{r}
rmarkdown::convert_ipynb(, output = xfun::with_ext(input, "Rmd"))
```

